% File-Based Session System with Command Accumulation
% Sessions are workspaces that accumulate commands, separate from Git
:- use_module(library(uuid)).

% Ensure prosqlite is installed, then import SQLite support
:- catch(use_module(library(prosqlite)), 
         error(existence_error(source_sink, library(prosqlite)), _),
         (format('Installing prosqlite pack...~n'),
          pack_install(prosqlite, [silent(true), interactive(false)]),
          use_module(library(prosqlite)))).

% === ENTITIES AND COMPONENTS ===

:- self_entity(session).
entity(think).

% Session commands
component(command, ctor, session).
component(session, subcommand, start).
component(session, subcommand, history).
component(session, subcommand, commit_accumulated).

% Think command
component(command, ctor, think).

docstring(session, "File-based session system. Sessions accumulate commands in workspace directories and can commit to Git when ready.").
docstring(think, "Record reasoning/thought process. Takes a string argument for LLM audit trails.").

% === CORE WORKSPACE PATHS ===

% Get Grimoire root directory: ${GRIMOIRE_ROOT:-$HOME/.grimoire}
grimoire_root_directory(RootDir) :-
    (getenv('GRIMOIRE_ROOT', CustomRoot) ->
        RootDir = CustomRoot
    ;
        getenv('HOME', HomeDir),
        format(atom(RootDir), '~w/.grimoire', [HomeDir])
    ).

% Session workspace directory: ${GRIMOIRE_ROOT}/sessions/{session-id}/
session_workspace_path(SessionId, WorkspacePath) :-
    grimoire_root_directory(GrimoireRoot),
    format(atom(WorkspacePath), '~w/sessions/~w', [GrimoireRoot, SessionId]).

% Commands database: workspace/commands.sqlite (prosqlite adds .sqlite automatically)
session_commands_db_path(SessionId, DbPath) :-
    session_workspace_path(SessionId, WorkspacePath),
    format(atom(DbPath), '~w/commands', [WorkspacePath]).

% Session state file: workspace/state.pl
session_state_file_path(SessionId, StatePath) :-
    session_workspace_path(SessionId, WorkspacePath),
    format(atom(StatePath), '~w/state.pl', [WorkspacePath]).

% === WORKSPACE MANAGEMENT ===

% Create session workspace
create_session_workspace(SessionId) :-
    session_workspace_path(SessionId, WorkspacePath),
    (exists_directory(WorkspacePath) ->
        true
    ;
        make_directory_path(WorkspacePath)
    ),
    initialize_commands_db(SessionId),
    initialize_state_file(SessionId).

% Initialize SQLite commands database with proper schema
initialize_commands_db(SessionId) :-
    session_commands_db_path(SessionId, DbPath),
    format(atom(ActualDbPath), '~w.sqlite', [DbPath]),
    (exists_file(ActualDbPath) ->
        true  % Database already exists
    ;
        catch(
            (% Create SQLite database with proper schema using prosqlite
             sqlite_connect(DbPath, session_init, [exists(false)]),
             
             % Create commands table with proper schema
             sqlite_query(session_init,
                'CREATE TABLE commands (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    command_type TEXT NOT NULL,
                    command_term TEXT NOT NULL,
                    result TEXT,
                    source TEXT DEFAULT "user"
                )'),
             
             % Create indexes for better query performance
             sqlite_query(session_init, 'CREATE INDEX idx_timestamp ON commands(timestamp)'),
             sqlite_query(session_init, 'CREATE INDEX idx_command_type ON commands(command_type)'),  
             sqlite_query(session_init, 'CREATE INDEX idx_source ON commands(source)'),
             
             sqlite_disconnect(session_init),
             
             true),
            Error,
            (format('Failed to initialize database: ~w~n', [Error]))
        )
    ).

% Initialize state file (replaces session-{id}.pl files)
initialize_state_file(SessionId) :-
    session_state_file_path(SessionId, StatePath),
    (exists_file(StatePath) ->
        true
    ;
        open(StatePath, write, Stream),
        format(Stream, '%% Session state file for session ~w~n', [SessionId]),
        format(Stream, '%% Auto-generated by Grimoire session system~n~n', []),
        close(Stream)
    ).

% === SESSION OPERATIONS ===

% Start new session
run(command(session(start)), RetVal) :-
    uuid(SessionId),
    run(command(session(start(SessionId))), RetVal).

run(command(session(start(SessionId))), RetVal) :-
    atom(SessionId),
    create_session_workspace(SessionId),
    format('ðŸ”® Session ~w started~n', [SessionId]),
    RetVal = ok(session_started(SessionId)).

% Show session command history
run(command(session(history)), RetVal) :-
    get_current_session_id(SessionId),
    get_session_command_history(SessionId, Commands),
    format('ðŸ“š Command history for session ~w:~n', [SessionId]),
    display_command_history(Commands),
    RetVal = ok(session_history(SessionId, Commands)).

% Commit accumulated commands to Git branch
run(command(session(commit_accumulated(Message))), RetVal) :-
    string(Message),
    format('ðŸ”® Would commit accumulated commands with message: ~s~n', [Message]),
    RetVal = ok(commit_accumulated_placeholder(Message)).

% === THINK COMMAND ===

% Think command - records reasoning with proper string handling
run(command(think(ThoughtString)), RetVal) :-
    string(ThoughtString), !,
    format('ðŸ’­ ~s~n', [ThoughtString]),
    % Log to session database
    log_command_to_session(think(ThoughtString), think, ok(thought_recorded(ThoughtString)), user),
    RetVal = ok(thought_recorded(ThoughtString)).

% Handle atom input by converting to string
run(command(think(ThoughtAtom)), RetVal) :-
    atom(ThoughtAtom),
    atom_string(ThoughtAtom, ThoughtString),
    run(command(think(ThoughtString)), RetVal).

% === COMMAND LOGGING ===

% Log command to current session database
log_command_to_session(Command, CommandType, Result, Source) :-
    get_current_session_id(SessionId),
    (SessionId = main ->
        true  % Don't log commands in main session
    ;
        log_command_to_session_db(SessionId, Command, CommandType, Result, Source)
    ).

% Log command to specific session database
log_command_to_session_db(SessionId, Command, CommandType, Result, Source) :-
    session_commands_db_path(SessionId, DbPath),
    format(atom(ActualDbPath), '~w.sqlite', [DbPath]),
    (exists_file(ActualDbPath) ->
        catch(
            (% Database exists, log the command
             ConnAlias = session_log,
             sqlite_connect(DbPath, ConnAlias, []),
             
             % Get current timestamp
             get_time(TimeStamp),
             format_time(atom(TimeStr), '%Y-%m-%dT%H:%M:%S', TimeStamp),
             
             % Convert terms to atoms for storage
             term_to_atom(Command, CommandAtom),
             term_to_atom(Result, ResultAtom),
             
             % Insert command into database using prosqlite format
             format(atom(InsertSQL), 
                'INSERT INTO commands (timestamp, command_type, command_term, result, source) VALUES ("~w", "~w", "~w", "~w", "~w")',
                [TimeStr, CommandType, CommandAtom, ResultAtom, Source]),
             sqlite_query(ConnAlias, InsertSQL),
             
             sqlite_disconnect(ConnAlias)),
            Error,
            format('Warning: Failed to log command: ~w~n', [Error])
        )
    ;
        true  % Database doesn't exist, silently fail
    ).

% Get current session ID 
get_current_session_id(SessionId) :-
    % TODO: Implement proper session tracking
    % For now, always return main
    SessionId = main.

% Session exists check (placeholder)
session_exists(_SessionId) :- 
    fail.  % For now, no sessions exist

% Add entity load to session state
add_entity_load_to_session(SessionId, EntitySpec) :-
    session_state_file_path(SessionId, StatePath),
    open(StatePath, append, Stream),
    format(Stream, '%% Entity loaded: ~w~n', [EntitySpec]),
    format(Stream, ':- load_entity(~q).~n~n', [EntitySpec]),
    close(Stream).

% Load session state file
load_session_state_file(SessionId) :-
    session_state_file_path(SessionId, StatePath),
    (exists_file(StatePath) ->
        consult(StatePath)
    ;
        true
    ).

% === DATABASE QUERY FUNCTIONS ===

% Get command history from session database
get_session_command_history(SessionId, Commands) :-
    (SessionId = main ->
        Commands = []  % Main session has no accumulated commands
    ;
        session_commands_db_path(SessionId, DbPath),
        format(atom(ActualDbPath), '~w.sqlite', [DbPath]),
        (exists_file(ActualDbPath) ->
            catch(
                (ConnAlias = session_query,
                 sqlite_connect(DbPath, ConnAlias, []),
                 findall(command_entry(Timestamp, CommandType, CommandTerm, Result, Source),
                         sqlite_query(ConnAlias,
                             'SELECT timestamp, command_type, command_term, result, source FROM commands ORDER BY timestamp DESC',
                             row(Timestamp, CommandType, CommandTerm, Result, Source)),
                         Commands),
                 sqlite_disconnect(ConnAlias)),
                Error,
                (format('Warning: Failed to query command history: ~w~n', [Error]),
                 Commands = [])
            )
        ;
            Commands = []  % No database file
        )
    ).

% Convert database row to command entry structure
row_to_command_entry(row(Timestamp, CommandType, CommandTerm, Result, Source), 
                     command_entry(Timestamp, CommandType, CommandTerm, Result, Source)).

% Display command history in readable format
display_command_history([]).
display_command_history([command_entry(Timestamp, CommandType, CommandTerm, Result, Source)|Rest]) :-
    format('  ~w [~w] (~w): ~w -> ~w~n', [Timestamp, Source, CommandType, CommandTerm, Result]),
    display_command_history(Rest).

% Get filtered command history
get_filtered_command_history(SessionId, Filters, Commands) :-
    get_session_command_history(SessionId, AllCommands),
    apply_command_filters(AllCommands, Filters, Commands).

% Apply filters to command history
apply_command_filters(Commands, [], Commands).
apply_command_filters(Commands, [type(Type)|RestFilters], FilteredCommands) :-
    include(command_has_type(Type), Commands, TypeFiltered),
    apply_command_filters(TypeFiltered, RestFilters, FilteredCommands).
apply_command_filters(Commands, [source(Source)|RestFilters], FilteredCommands) :-
    include(command_has_source(Source), Commands, SourceFiltered),
    apply_command_filters(SourceFiltered, RestFilters, FilteredCommands).

% Filter predicates
command_has_type(Type, command_entry(_, Type, _, _, _)).
command_has_source(Source, command_entry(_, _, _, _, Source)).