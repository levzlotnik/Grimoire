#!/usr/bin/env swipl
% Grimoire - Knowledge-Based Operating System CLI
% Interface wrapper that formats results from interface.pl

:- initialization(main, main).

% Load grimoire system + interface layer
:- ensure_loaded('src/prolog/grimoire.pl').
:- ensure_loaded('src/prolog/interface.pl').

% Main entry point - parse command line arguments
main(Args) :-
    (Args = [] ->
        show_usage,
        halt(1)
    ; Args = [Command|RestArgs] ->
        (handle_command(Command, RestArgs) ->
            halt(0)
        ;
            halt(1)
        )
    ; 
        show_usage,
        halt(1)
    ).

% Auto-generated usage from interface components
show_usage :-
    writeln(''),
    writeln('ðŸ”® Grimoire - Knowledge-Based Operating System'),
    writeln(''),
    catch(current_entity(CurrentEntity), _, CurrentEntity = system),
    format('Context: ~w~n~n', [CurrentEntity]),
    writeln('Available commands:'),
    findall(Cmd, component(interface, subcommand, Cmd), Commands),
    forall(member(Cmd, Commands), (
        (docstring(interface(Cmd), Doc) ->
            true
        ;
            Doc = "No documentation available"
        ),
        format('  ~w~t~12| - ~w~n', [Cmd, Doc])
    )),
    writeln(''),
    writeln('Usage patterns:'),
    writeln('  grimoire compt [entity]         # List component types'),
    writeln('  grimoire comp <type> [entity]   # List components of type'),
    writeln('  grimoire doc [entity]           # Show documentation'),
    writeln(''),
    writeln('Spell-based commands:'),
    writeln('  grimoire cast "conjure(...)"    # Cast mutation spells'),
    writeln('  grimoire perceive "query(...)"  # Execute perception queries'),
    writeln('').

% === COMMAND DISPATCH ===

% Component types command
handle_command(compt, []) :-
    !,
    run(command(interface(compt)), Result),
    format_cli_result(Result).

handle_command(compt, [EntityStr]) :-
    !,
    atom_string(EntityAtom, EntityStr),
    run(command(interface(compt(EntityAtom))), Result),
    format_cli_result(Result).

% Component listing command
handle_command(comp, [TypeStr]) :-
    !,
    atom_string(TypeAtom, TypeStr),
    run(command(interface(comp(TypeAtom))), Result),
    format_cli_result(Result).

handle_command(comp, [TypeStr, EntityStr]) :-
    !,
    atom_string(TypeAtom, TypeStr),
    atom_string(EntityAtom, EntityStr),
    run(command(interface(comp(TypeAtom, EntityAtom))), Result),
    format_cli_result(Result).

% Documentation command
handle_command(doc, []) :-
    !,
    run(command(interface(doc)), Result),
    format_cli_result(Result).

handle_command(doc, [EntityStr]) :-
    !,
    atom_string(EntityAtom, EntityStr),
    run(command(interface(doc(EntityAtom))), Result),
    format_cli_result(Result).

% REPL command
handle_command(repl, _) :-
    !,
    run(command(interface(repl)), Result),
    format_cli_result(Result).

% Status command  
handle_command(status, _) :-
    !,
    run(command(interface(status)), Result),
    format_cli_result(Result).

% Test command
handle_command(test, _) :-
    !,
    run(command(interface(test)), Result),
    format_cli_result(Result).

% Session commands
handle_command(session, [SubCmd|Args]) :-
    !,
    % Parse session subcommand
    atom_string(SubCmdAtom, SubCmd),
    parse_session_args(SubCmdAtom, Args, SessionArgs),
    run(command(interface(session(SessionArgs))), Result),
    format_cli_result(Result).

% Cast command - execute conjuration spells
handle_command(cast, [SpellStr]) :-
    !,
    % Parse the spell string as a Prolog term
    catch(
        (read_term_from_atom(SpellStr, SpellTerm, []),
         run(command(interface(cast(SpellTerm))), Result),
         format_cli_result(Result)),
        Error,
        format_cli_result(error(invalid_spell_syntax(Error)))
    ).

% Perceive command - execute perception spells with auto-variable output
handle_command(perceive, [QueryStr]) :-
    !,
    % Parse the query string as a Prolog term with variable names
    catch(
        (read_term_from_atom(QueryStr, QueryTerm, [variable_names(VarNames)]),
         execute_perceive_query(QueryTerm, VarNames)),
        Error,
        format_cli_result(error(invalid_query_syntax(Error)))
    ).

% Legacy run command - for backwards compatibility
handle_command(run, [CommandStr]) :-
    !,
    % Parse the command string as a Prolog term
    catch(
        (read_term_from_atom(CommandStr, CommandTerm, []),
         run(command(interface(run(CommandTerm))), Result),
         format_cli_result(Result)),
        Error,
        format_cli_result(error(invalid_command_syntax(Error)))
    ).

% Unknown command
handle_command(Command, _) :-
    format('Unknown command: ~w~n~n', [Command]),
    show_usage,
    fail.

% === CLI FORMATTING FUNCTIONS ===

% Format component types result
format_cli_result(ok(component_types(Entity, Types))) :-
    !,
    format('~w component types:~n', [Entity]),
    forall(member(Type, Types), format('  ~w~n', [Type])).

% Format components listing result
format_cli_result(ok(components(Entity, Type, Components))) :-
    !,
    format('~w components of type "~w":~n~n', [Entity, Type]),
    format('Component~t~28| | v/e~n'),
    format('~`-t~32|~n'),
    forall(member(comp_entry(Comp, Flag), Components), (
        (Flag = entity -> DisplayFlag = 'e' ; DisplayFlag = 'v'),
        format('~w~t~28| | ~w~n', [Comp, DisplayFlag])
    )).

% Format documentation result - no docstring available
format_cli_result(ok(documentation(Entity, no_docstring_available))) :-
    !,
    format('No docstring available for ~w~n', [Entity]).

% Format documentation result - has docstring
format_cli_result(ok(documentation(Entity, Doc))) :-
    !,
    format('~w:~n~w~n', [Entity, Doc]).

% Format session status result
format_cli_result(ok(session_status(status_info(CurrentBranch, WorkingStatus, Sessions)))) :-
    !,
    format('ðŸ”® Grimoire Session Status~n~n'),
    format('Current Branch: ~w~n', [CurrentBranch]),
    format('Working Tree: ~w~n~n', [WorkingStatus]),
    format('Available Sessions:~n'),
    format_sessions(Sessions).

% Format success results
format_cli_result(ok(repl_completed)) :-
    !,
    true.  % REPL handles its own output

format_cli_result(ok(tests_passed)) :-
    !,
    writeln('All tests passed âœ“').

% Format session results
format_cli_result(ok(session_started(SessionId, Type, State, Method))) :-
    !,
    format('Session ~w started (~w session, ~w state, ~w)~n', [SessionId, Type, State, Method]).

format_cli_result(ok(session_closed(SessionId, Strategy))) :-
    !,
    format('Session ~w closed (~w)~n', [SessionId, Strategy]).

format_cli_result(ok(transaction_executed(Results, State))) :-
    !,
    length(Results, NumResults),
    format('Transaction executed (~w) with ~w results~n', [State, NumResults]).

% Format error results
format_cli_result(error(Reason)) :-
    !,
    format('Error: ~w~n', [Reason]).

% Format command execution results
format_cli_result(ok(result(Stdout, Stderr))) :-
    !,
    (Stdout \= "" -> write(Stdout) ; true),
    (Stderr \= "" -> (write('STDERR: '), write(Stderr)) ; true).

% Fallback for unexpected results
format_cli_result(Result) :-
    format('Unexpected result: ~w~n', [Result]).

% === SESSION FORMATTING HELPERS ===

format_sessions([]) :-
    writeln('  (no sessions found)').
    
format_sessions(Sessions) :-
    Sessions \= [],
    format_all_sessions(Sessions).

format_all_sessions([]).
format_all_sessions([Session|Rest]) :-
    format_single_session(Session),
    format_all_sessions(Rest).

format_single_session(active(main)) :-
    !,
    writeln('  * main (active, main session)').
    
format_single_session(main) :-
    !,
    writeln('    main (main session)').
    
format_single_session(active(SessionId)) :-
    !,
    format('  * session-~w (active)~n', [SessionId]).
    
format_single_session(SessionId) :-
    format('    session-~w~n', [SessionId]).

% === SESSION ARGUMENT PARSING ===

% Parse session subcommand arguments
parse_session_args(start, [], start) :- !.
parse_session_args(start, [SessionIdStr], start(SessionId)) :-
    !,
    atom_string(SessionId, SessionIdStr).
parse_session_args(close, [SessionIdStr, StrategyStr], close(SessionId, Strategy)) :-
    !,
    atom_string(SessionId, SessionIdStr),
    atom_string(Strategy, StrategyStr).
parse_session_args(execute, [SessionIdStr, CommandsStr], execute(SessionId, Commands)) :-
    !,
    atom_string(SessionId, SessionIdStr),
    % Parse commands as Prolog term
    read_term_from_atom(CommandsStr, Commands, []).

% === PERCEIVE QUERY EXECUTION ===

% Execute a perceive query and automatically emit variable bindings
execute_perceive_query(QueryTerm, VarNames) :-
    % Try perceive() wrapper first (for domain operations), then direct call
    (perceive(QueryTerm) ->
        emit_variable_bindings(VarNames)
    ; call(QueryTerm) ->
        emit_variable_bindings(VarNames)
    ;
        writeln('Query failed - no solutions found')
    ).

% Emit variable bindings in Variable = Value format
emit_variable_bindings([]).
emit_variable_bindings([Name=Value|Rest]) :-
    format('~w = ~w~n', [Name, Value]),
    emit_variable_bindings(Rest).